(ns middleware.code-generator-test2
  (:refer-clojure :exclude [print])
  (:require #?(:clj [clojure.test :refer :all]
               :cljs [cljs.test :refer-macros [deftest is testing use-fixtures]])
            [utils.compile-stats :refer [register-program!]]
            [utils.tests :refer [setup-fixture]]
            [middleware.compilation.codegen :as cg]
            [middleware.compilation.parser :as pp]))

(use-fixtures :once setup-fixture)

(defn parse [src]
  (let [ast (pp/parse src)]
    (register-program! ast)
    ast))

; NOTE(Richo): The following tests were autogenerated

(deftest parsing-negative-numbers-larger-than-minus-1
  (let [expected (parse "task foo() { return -0.5; }")
        actual (parse (cg/generate-code expected))]
    (is (= expected actual))))

(deftest empty-program
  (let [expected (parse "")
        actual (parse (cg/generate-code expected))]
    (is (= expected actual))))

(deftest blink13
  (let [expected (parse "task default() running 1/s {\n\ttoggle(D13);\n}")
        actual (parse (cg/generate-code expected))]
    (is (= expected actual))))

(deftest procedure-with-argument
  (let [expected (parse "proc blink(arg0) {\n\tturnOn(arg0);\n\tdelayS(1);\n\tturnOff(arg0);\n}")
        actual (parse (cg/generate-code expected))]
    (is (= expected actual))))

(deftest function-with-arguments
  (let [expected (parse "func default(arg0, arg1) {\n\treturn (arg0 % arg1);\n}")
        actual (parse (cg/generate-code expected))]
    (is (= expected actual))))

(deftest functions-with-calls-and-globals
  (let [expected (parse "var global;\n\nfunc forIncrease(from, to, by) {\n\tfor i = from to to by by {\n\t\tglobal = (global + 1);\n\t}\n\treturn global;\n}\n\nfunc run() {\n\tvar temp = forIncrease(1, 10, 0.5);\n}")
        actual (parse (cg/generate-code expected))]
    (is (= expected actual))))

(deftest operator-precedence
  (let [expected (parse "func operate(arg0, arg1) {\n\treturn arg0 + arg1**2*3;\n}")
        actual (parse (cg/generate-code expected))]
    (is (= expected actual))))

(deftest custom-operator-precedence
  (let [expected (parse "prim ~ : add;\nfunc foo(a,b,c,d,n,j) {\nreturn a * b/c**d+n ~ j ** 3;\n } ")
        actual (parse (cg/generate-code expected))]
    (is (= expected actual))))

(deftest control-structures
  (let [expected (parse "task while_loop() {\n\twhile 1 {\n\t\twhile 1;\n\t}\n}\n\ntask until_loop() {\n\tuntil 1 {\n\t\tuntil 1;\n\t}\n}\n\ntask repeat_forever() {\n\tforever {\n\t\trepeat 5 {}\n\t}\n}\n\ntask conditional() {\n\tif 1 {\n\t\tif 0 {\n\t\t\tdelayS(1000);\n\t\t}\n\t} else {\n\t\tdelayMs(1000);\n\t}\n}")
        actual (parse (cg/generate-code expected))]
    (is (= expected actual))))

(deftest control-structures-part-II
  (let [expected (parse "task test()\n{\n\tdo{var a = 3;}\n\tuntil(1);\n\tdo{\n\t\tvar a= 4;\n\t\tyield;\n\t}while(1);\n}")
        actual (parse (cg/generate-code expected))]
    (is (= expected actual))))

(deftest motor-usage
  (let [expected (parse "import motor from 'DCMotor.uzi' {\n\tenablePin = D10;\n\tforwardPin = D9;\n\treversePin = D8;\n}\n\ntask servo() {\n\tforever {\n\t\tsetServoDegrees(D3, 90);\n\t\tdelayMs(1000);\n\t\tsetServoDegrees(D3, 0);\n\t\tdelayMs(1000);\n\t}\n}\n\ntask default1() running 20/m {\n\tmotor.forward(speed: 1);\n\tdelayMs(1000);\n\tmotor.brake();\n\tdelayMs(1000);\n}")
        actual (parse (cg/generate-code expected))]
    (is (= expected actual))))

(deftest sonar-and-button
  (let [expected (parse "import sonar from 'Sonar.uzi' {\n\ttrigPin = D11;\n\techoPin = D12;\n\tmaxDistance = 200;\n\tstart reading;\n}\nimport buttons from 'Buttons.uzi' {\n\tdebounceMs = 50;\n}\n\nvar variable1;\n\ntask sonar() stopped 1/h {\n\twrite(D13, sonar.distance_cm());\n}\n\ntask button() running 1/s {\n\tif variable1 {\n\t\tbuttons.waitForRelease(D7);\n\t\tvariable1 = !variable1;\n\t\tstart sonar;\n\t} else {\n\t\tstop sonar;\n\t}\n}")
        actual (parse (cg/generate-code expected))]
    (is (= expected actual))))

(deftest primitive-definition
  (let [expected (parse "\nprim add;\nprim ~= : notEquals;\n\ntask test() {\n\tvar a = add(3, 4);\n\tvar b = 3 ~= 4;\n}")
        actual (parse (cg/generate-code expected))]
    (is (= expected actual))))

(deftest uzi-syntax
  (let [expected (parse "\"This is just an example of code that uses all the available syntax\nin the language.\"\n\"I wrote it to help me create a syntax highlighter for the \"\"Ace\"\" editor\"\n\nimport foo from 'DCMotor.uzi';\nimport bar from 'Sonar.uzi' {\n  trigPin = 100;\n  echoPin = 200;\n  start reading;\n  stop reading;\n  pause reading;\n  resume reading;\n}\n\nvar a = 10;\nvar b = 0.5;\nvar c;\n\ntask blink13() running 2/s { toggle(D13); }\ntask blink12() running 1/s { toggle(D12); }\n\ntask setup() {\n    if a { turnOn(D11); }\n    else { turnOff(D11); }\n}\n\nfunc fact(n) {\n    if n == 0 { return 1; }\n    return n * fact(n - 1);\n}\n\nproc foo_bar_baz(a, b, c) {\n    var d = a * b + c;\n    repeat d { toggle(A2); }\n    forever {\n        start blink13, blink12;\n        stop blink13;\n        yield;\n        pause blink12, blink13;\n        resume blink12; yield;\n        return;\n    }\n    while 1 && 0 { toggle(D10); delayMs(1000); }\n    until 0 || 0 { toggle(D10); delayMs(1000); }\n    while 1 >= 0; \"Body is optional\"\n    until 0 <= 1; \"Body is optional\"\n    do { toggle(D9); } while 1 > 0;\n    do { toggle(D8); } until 0 < 1;\n    for i = 0 to 10 by 1 {\n        toggle(A0);\n        delayMs(i * 100);\n    }\n\tvar e = foo.getSpeed();\n\tfoo.init(fact(1 * -2 + -3.5), a + b/d, 0);\n\tbar.init(trig: a, echo: b, maxDist: c);\n}\n")
        actual (parse (cg/generate-code expected))]
    (is (= expected actual))))

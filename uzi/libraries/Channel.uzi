var value;
var state; "0 : write, 1 : read"
var rturn = -1;
var wturn = -1;

proc write(val) {
	"Wait until it's our turn to write by checking
	wturn, if it matches our coroutine index then we
	can continue (it's our turn!). If not, we look for
	wturn == -1, which means nobody is attempting to
	write to the channel. If that's the case we simply
	set wturn = to our coroutine index so that nobody
	else can claim it"
	while coroutine() != wturn {
		if wturn == -1 {
			wturn = coroutine();
			"TODO(Richo): The following yield is not required 
			right now but if the vm implementation changes the 
			behavior of backwards jumps it will ensure the
			correct functionality"
			yield;
		}
	}
	"Now we wait until it's time to write. It might be
	our turn to write but someone might be reading"
	while state != 0;
	
	"Release wturn so that the next coroutine in line 
	can get their turn"
	wturn = -1;
	yield;
	"Write the value to the channel"
	value = val;
	"Set the state to ready-to-read"
	state = 1;
	"Wait until the state is ready-to-write again"
	while state != 0;	
}

func read() {
	"Wait until it's our turn to read by checking
	rturn, if it matches our coroutine index then we
	can continue (it's our turn!). If not, we look for
	rturn == -1, which means nobody is attempting to
	read from the channel. If that's the case we simply
	set rturn = to our coroutine index so that nobody
	else can claim it"
	while coroutine() != rturn {
		if rturn == -1 {
			rturn = coroutine();
			"TODO(Richo): The following yield is not required 
			right now but if the vm implementation changes the 
			behavior of backwards jumps it will ensure the
			correct functionality"
			yield;
		}
	}
	"Now we wait until it's time to read"
	while state != 1;
	
	rturn = -1;
	yield;
	state = 0;
	return value;
}